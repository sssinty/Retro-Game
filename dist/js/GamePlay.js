"use strict";

require("core-js/modules/es.object.define-property.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.date.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.array.is-array.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/es.array.index-of.js");
require("core-js/modules/es.array.for-each.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.for-each.js");
require("core-js/modules/es.array.filter.js");
require("core-js/modules/es.string.starts-with.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.symbol.to-primitive.js");
require("core-js/modules/es.date.to-primitive.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.number.constructor.js");
var _utils = require("./utils");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var GamePlay = exports["default"] = /*#__PURE__*/function () {
  function GamePlay() {
    _classCallCheck(this, GamePlay);
    this.boardSize = 8;
    this.container = null;
    this.boardEl = null;
    this.cells = [];
    this.cellClickListeners = [];
    this.cellEnterListeners = [];
    this.cellLeaveListeners = [];
    this.newGameListeners = [];
    this.saveGameListeners = [];
    this.loadGameListeners = [];
  }
  _createClass(GamePlay, [{
    key: "bindToDOM",
    value: function bindToDOM(container) {
      if (!(container instanceof HTMLElement)) {
        throw new Error('container is not HTMLElement');
      }
      this.container = container;
    }

    /**
     * Draws boardEl with specific theme
     *
     * @param theme
     */
  }, {
    key: "drawUi",
    value: function drawUi(theme) {
      var _this = this;
      this.checkBinding();
      this.container.innerHTML = "\n      <div class=\"controls\">\n        <button data-id=\"action-restart\" class=\"btn\">New Game</button>\n        <button data-id=\"action-save\" class=\"btn\">Save Game</button>\n        <button data-id=\"action-load\" class=\"btn\">Load Game</button>\n      </div>\n      <div class=\"board-container\">\n        <div data-id=\"board\" class=\"board\"></div>\n      </div>\n    ";
      this.newGameEl = this.container.querySelector('[data-id=action-restart]');
      this.saveGameEl = this.container.querySelector('[data-id=action-save]');
      this.loadGameEl = this.container.querySelector('[data-id=action-load]');
      this.newGameEl.addEventListener('click', function (event) {
        return _this.onNewGameClick(event);
      });
      this.saveGameEl.addEventListener('click', function (event) {
        return _this.onSaveGameClick(event);
      });
      this.loadGameEl.addEventListener('click', function (event) {
        return _this.onLoadGameClick(event);
      });
      this.boardEl = this.container.querySelector('[data-id=board]');
      this.boardEl.classList.add(theme);
      for (var i = 0; i < Math.pow(this.boardSize, 2); i += 1) {
        var cellEl = document.createElement('div');
        cellEl.classList.add('cell', 'map-tile', "map-tile-".concat((0, _utils.calcTileType)(i, this.boardSize)));
        cellEl.addEventListener('mouseenter', function (event) {
          return _this.onCellEnter(event);
        });
        cellEl.addEventListener('mouseleave', function (event) {
          return _this.onCellLeave(event);
        });
        cellEl.addEventListener('click', function (event) {
          return _this.onCellClick(event);
        });
        this.boardEl.appendChild(cellEl);
      }
      this.cells = Array.from(this.boardEl.children);
    }

    /**
     * Draws positions (with chars) on boardEl
     *
     * @param positions array of PositionedCharacter objects
     */
  }, {
    key: "redrawPositions",
    value: function redrawPositions(positions) {
      var _iterator = _createForOfIteratorHelper(this.cells),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var cell = _step.value;
          cell.innerHTML = '';
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var _iterator2 = _createForOfIteratorHelper(positions),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var position = _step2.value;
          var cellEl = this.boardEl.children[position.position];
          var charEl = document.createElement('div');
          charEl.classList.add('character', position.character.type);
          var healthEl = document.createElement('div');
          healthEl.classList.add('health-level');
          var healthIndicatorEl = document.createElement('div');
          healthIndicatorEl.classList.add('health-level-indicator', "health-level-indicator-".concat((0, _utils.calcHealthLevel)(position.character.health)));
          healthIndicatorEl.style.width = "".concat(position.character.health, "%");
          healthEl.appendChild(healthIndicatorEl);
          charEl.appendChild(healthEl);
          cellEl.appendChild(charEl);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }

    /**
     * Add listener to mouse enter for cell
     *
     * @param callback
     */
  }, {
    key: "addCellEnterListener",
    value: function addCellEnterListener(callback) {
      this.cellEnterListeners.push(callback);
    }

    /**
     * Add listener to mouse leave for cell
     *
     * @param callback
     */
  }, {
    key: "addCellLeaveListener",
    value: function addCellLeaveListener(callback) {
      this.cellLeaveListeners.push(callback);
    }

    /**
     * Add listener to mouse click for cell
     *
     * @param callback
     */
  }, {
    key: "addCellClickListener",
    value: function addCellClickListener(callback) {
      this.cellClickListeners.push(callback);
    }

    /**
     * Add listener to "New Game" button click
     *
     * @param callback
     */
  }, {
    key: "addNewGameListener",
    value: function addNewGameListener(callback) {
      this.newGameListeners.push(callback);
    }

    /**
     * Add listener to "Save Game" button click
     *
     * @param callback
     */
  }, {
    key: "addSaveGameListener",
    value: function addSaveGameListener(callback) {
      this.saveGameListeners.push(callback);
    }

    /**
     * Add listener to "Load Game" button click
     *
     * @param callback
     */
  }, {
    key: "addLoadGameListener",
    value: function addLoadGameListener(callback) {
      this.loadGameListeners.push(callback);
    }
  }, {
    key: "onCellEnter",
    value: function onCellEnter(event) {
      event.preventDefault();
      var index = this.cells.indexOf(event.currentTarget);
      this.cellEnterListeners.forEach(function (o) {
        return o.call(null, index);
      });
    }
  }, {
    key: "onCellLeave",
    value: function onCellLeave(event) {
      event.preventDefault();
      var index = this.cells.indexOf(event.currentTarget);
      this.cellLeaveListeners.forEach(function (o) {
        return o.call(null, index);
      });
    }
  }, {
    key: "onCellClick",
    value: function onCellClick(event) {
      var index = this.cells.indexOf(event.currentTarget);
      this.cellClickListeners.forEach(function (o) {
        return o.call(null, index);
      });
    }
  }, {
    key: "onNewGameClick",
    value: function onNewGameClick(event) {
      event.preventDefault();
      this.newGameListeners.forEach(function (o) {
        return o.call(null);
      });
    }
  }, {
    key: "onSaveGameClick",
    value: function onSaveGameClick(event) {
      event.preventDefault();
      this.saveGameListeners.forEach(function (o) {
        return o.call(null);
      });
    }
  }, {
    key: "onLoadGameClick",
    value: function onLoadGameClick(event) {
      event.preventDefault();
      this.loadGameListeners.forEach(function (o) {
        return o.call(null);
      });
    }
  }, {
    key: "selectCell",
    value: function selectCell(index) {
      var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'yellow';
      this.deselectCell(index);
      this.cells[index].classList.add('selected', "selected-".concat(color));
    }
  }, {
    key: "deselectCell",
    value: function deselectCell(index) {
      var _cell$classList;
      var cell = this.cells[index];
      (_cell$classList = cell.classList).remove.apply(_cell$classList, _toConsumableArray(Array.from(cell.classList).filter(function (o) {
        return o.startsWith('selected');
      })));
    }
  }, {
    key: "showCellTooltip",
    value: function showCellTooltip(message, index) {
      this.cells[index].title = message;
    }
  }, {
    key: "hideCellTooltip",
    value: function hideCellTooltip(index) {
      this.cells[index].title = '';
    }
  }, {
    key: "showDamage",
    value: function showDamage(index, damage) {
      var _this2 = this;
      return new Promise(function (resolve) {
        var cell = _this2.cells[index];
        var damageEl = document.createElement('span');
        damageEl.textContent = damage;
        damageEl.classList.add('damage');
        cell.appendChild(damageEl);
        damageEl.addEventListener('animationend', function () {
          cell.removeChild(damageEl);
          resolve();
        });
      });
    }
  }, {
    key: "setCursor",
    value: function setCursor(cursor) {
      this.boardEl.style.cursor = cursor;
    }
  }, {
    key: "checkBinding",
    value: function checkBinding() {
      if (this.container === null) {
        throw new Error('GamePlay not bind to DOM');
      }
    }
  }], [{
    key: "showError",
    value: function showError(message) {
      alert(message);
    }
  }, {
    key: "showMessage",
    value: function showMessage(message) {
      alert(message);
    }
  }]);
  return GamePlay;
}();